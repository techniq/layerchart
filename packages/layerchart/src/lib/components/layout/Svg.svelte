<script lang="ts" module>
  type SVGPropsWithoutHTML = {
    /**
     * A reference to the layer's `<svg>` tag.
     *
     * @bindable
     */
    element?: SVGElement | null;
    /**
     * A reference to the layer's `<g>` tag.
     *
     * @bindable
     */
    innerElement?: SVGGElement | null;

    /**
     * The layer's z-index.
     */
    zIndex?: number;

    /**
     * Set this to `false` to set `pointer-events: none;` on the entire layer.
     */
    pointerEvents?: boolean;

    /**
     * A string passed to the `viewBox` property on the `<svg>` tag.
     */
    viewBox?: string;

    /**
     * A string passed to the `aria-label` property on the `<svg>` tag.
     */
    label?: string;

    /**
     * A string passed to the `aria-labelledby` property on the `<svg>` tag.
     */
    labelledBy?: string;

    /**
     * A string passed to the `aria-describedby` property on the `<svg>` tag.
     */
    describedBy?: string;

    /**
     * Shorthand to set the contents of `<title></title>` for accessibility.
     * You can also set arbitrary HTML via the title snippet but this is a convenient shorthand.
     */
    title?: string | Snippet;

    /**
     * The inner content of the `<defs>` tag.
     */
    defs?: Snippet;

    /**
     * Translate children to center (useful for radial layouts)
     */
    center?: boolean | 'x' | 'y';

    /**
     * Ignore TransformContext.
     * Useful to add static elements such as legends.
     */
    ignoreTransform?: boolean;

    children?: Snippet<[{ element: SVGElement }]>;
  };

  export type SVGProps = SVGPropsWithoutHTML &
    Without<SVGAttributes<SVGElement>, SVGPropsWithoutHTML>;
</script>

<script lang="ts">
  import { cls } from '@layerstack/tailwind';
  import { getTransformContext } from '../TransformContext.svelte';
  import type { Snippet } from 'svelte';
  import type { Without } from '$lib/utils/types.js';
  import type { SVGAttributes } from 'svelte/elements';
  import { getChartContext, setRenderContext } from '../Chart-Next.svelte';

  let {
    element = $bindable(null),
    innerElement = $bindable(null),
    zIndex = 0,
    pointerEvents,
    viewBox,
    ignoreTransform = false,
    center = false,
    class: className,
    label,
    labelledBy,
    describedBy,
    title,
    defs,
    children,
    ...restProps
  }: SVGProps = $props();

  const ctx = getChartContext();
  const transformCtx = getTransformContext();

  const transform = $derived.by(() => {
    if (transformCtx.mode === 'canvas' && !ignoreTransform) {
      return `translate(${transformCtx.translate.x},${transformCtx.translate.y}) scale(${transformCtx.scale})`;
    } else if (center) {
      return `translate(${center === 'x' || center === true ? ctx.width / 2 : 0}, ${center === 'y' || center === true ? ctx.height / 2 : 0})`;
    }
  });

  setRenderContext('svg');
</script>

<svg
  bind:this={element}
  {viewBox}
  width={ctx.containerWidth}
  height={ctx.containerHeight}
  style:z-index={zIndex}
  class={cls(
    'layerchart-layout-svg',
    'absolute top-0 left-0 overflow-visible',
    pointerEvents === false && 'pointer-events-none',
    className
  )}
  aria-label={label}
  aria-labelledby={labelledBy}
  aria-describedby={describedBy}
  role="figure"
  {...restProps}
>
  {#if title}
    {#if typeof title === 'function'}
      {@render title()}
    {:else}
      <title class="layerchart-title">{title}</title>
    {/if}
  {/if}

  <defs>
    {@render defs?.()}
  </defs>

  <g
    bind:this={innerElement}
    class="layerchart-layout-svg_g"
    transform="translate({ctx.padding.left}, {ctx.padding.top})"
  >
    {#if transform}
      <g {transform}>
        {@render children?.({ element: element as SVGElement })}
      </g>
    {:else}
      {@render children?.({ element: element as SVGElement })}
    {/if}
  </g>
</svg>
