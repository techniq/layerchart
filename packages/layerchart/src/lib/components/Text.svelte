<script lang="ts" module>
  import type { CommonStyleProps, Without } from '$lib/utils/types.js';
  import type { SVGAttributes } from 'svelte/elements';
  import { createMotion, type MotionProp } from '$lib/utils/motion.svelte.js';

  export type TextPropsWithoutHTML = {
    /**
     * text value
     * @default 0
     */
    value?: string | number;

    /**
     * The fill color of the text
     */
    fill?: string;

    /**
     * Maximum width to occupy (approximate as words are not split)
     */
    width?: number;

    /**
     * x position of the text
     *
     * @default 0
     */
    x?: string | number;

    /**
     * Initial x position of the text
     *
     * @default x
     */
    initialX?: string | number;

    /**
     * y position of the text
     *
     * @default 0
     */
    y?: string | number;

    /**
     * Initial y position of the text
     *
     * @default y
     */
    initialY?: string | number;

    /**
     * dx offset of the text
     *
     * @default 0
     */
    dx?: string | number;

    /**
     * dy offset of the text
     *
     * @default 0
     */
    dy?: string | number;

    /**
     * Desired "line height" of the text, implemented as y offsets
     *
     * @default "1em"
     */
    lineHeight?: string;

    /**
     * Cap height of the text
     * @default '0.71em'
     */
    capHeight?: string;

    /**
     * Whether to scale the fontSize to accommodate the specified width
     *
     * @default false
     */

    scaleToFit?: boolean;

    /**
     * Horizontal text anchor
     *
     * @default 'start'
     */
    textAnchor?: 'start' | 'middle' | 'end' | 'inherit';

    /**
     * Vertical text anchor
     *
     * @default 'end'
     */
    verticalAnchor?: 'start' | 'middle' | 'end' | 'inherit';

    /**
     * The dominant baseline of the text.  Useful for aligning text to the baseline of the axis.
     *
     * @default 'auto'
     */
    dominantBaseline?:
      | 'auto'
      | 'text-before-edge'
      | 'text-after-edge'
      | 'middle'
      | 'hanging'
      | 'ideographic'
      | 'mathematical';

    /**
     * Rotational angle of the text
     */
    rotate?: number;

    /**
     * A bindable reference to the wrapping `<svg>` element.
     *
     * @bindable
     */
    svgRef?: SVGElement;

    /**
     * Props to pass to the wrapping `<svg>` element.
     */
    svgProps?: Omit<SVGAttributes<SVGElement>, 'children'>;

    /**
     * A bindable reference to the inner `<text>` element
     *
     * @bindable
     */
    ref?: SVGTextElement;
    motion?: MotionProp;

    /**
     * Whether to enable text truncation
     */
    truncate?: boolean | TruncateTextOptions;

    /**
     * A unique identifier for the SVG path element.
     * One is generated by default if not provided.
     *
     */
    pathId?: string;

    /**
     * The path to render the text along.
     */
    path?: string | null;

    /**
     * Specify the offset for the start of the text along the path.
     * Can be a percentage ('50%') or a length value.
     *
     * @default '0%'
     */
    startOffset?: string | number;
  } & CommonStyleProps;

  export type TextProps = TextPropsWithoutHTML &
    Without<SVGAttributes<SVGTextElement>, TextPropsWithoutHTML>;

  function getPathLength(pathRef: SVGPathElement | undefined) {
    if (pathRef && typeof pathRef.getTotalLength === 'function') {
      try {
        return pathRef.getTotalLength();
      } catch (e) {
        console.error('Error getting path length:', e);
        return 0;
      }
    }
    return 0;
  }
</script>

<script lang="ts">
  import { cls } from '@layerstack/tailwind';
  import { merge } from 'lodash-es';

  import { getRenderContext } from './Chart.svelte';
  import { registerCanvasComponent } from './layout/Canvas.svelte';
  import { getStringWidth, truncateText, type TruncateTextOptions } from '$lib/utils/string.js';
  import { getComputedStyles, renderText, type ComputedStylesOptions } from '../utils/canvas.js';

  import { createKey } from '$lib/utils/key.svelte.js';
  import { layerClass } from '$lib/utils/attributes.js';
  import { degreesToRadians } from '$lib/utils/math.js';
  import { createId } from '$lib/utils/createId.js';

  const uid = $props.id();

  let {
    value,
    x = 0,
    initialX = x,
    y = 0,
    initialY = y,
    dx = 0,
    dy = 0,
    lineHeight = '1em',
    capHeight = '0.71em',
    width,
    scaleToFit = false,
    textAnchor = 'start',
    verticalAnchor = 'end',
    dominantBaseline = 'auto',
    rotate,
    opacity = 1,
    strokeWidth = 0,
    stroke,
    fill,
    fillOpacity,
    motion,
    svgRef: svgRefProp = $bindable(),
    ref: refProp = $bindable(),
    class: className,
    svgProps = {},
    truncate = false,
    path,
    pathId = createId('text-path', uid),
    startOffset = '0%',
    transform: transformProp,
    ...restProps
  }: TextProps = $props();

  const renderCtx = getRenderContext();

  let ref = $state<SVGTextElement>();
  let svgRef = $state<SVGElement>();
  let pathRef = $state<SVGPathElement>();

  $effect.pre(() => {
    refProp = ref;
  });

  $effect.pre(() => {
    svgRefProp = svgRef;
  });

  let style = $state<CSSStyleDeclaration>(); // TODO: read from DOM?

  const resolvedWidth = $derived(path ? getPathLength(pathRef) : width);

  const defaultTruncateOptions: TruncateTextOptions = $derived({
    maxChars: undefined,
    position: 'end',
    maxWidth: resolvedWidth,
  });

  const truncateConfig: TruncateTextOptions | boolean = $derived.by(() => {
    if (typeof truncate === 'boolean') {
      if (truncate) return defaultTruncateOptions;
      return false;
    }
    return {
      ...defaultTruncateOptions,
      ...truncate,
    };
  });

  // Handle null and convert `\n` strings back to newline characters
  const rawText = $derived(value != null ? value.toString().replace(/\\n/g, '\n') : '');

  const textValue = $derived.by(() => {
    if (!truncateConfig) return rawText;
    return truncateText(rawText, truncateConfig);
  });

  const spaceWidth = $derived(getStringWidth('\u00A0', style) || 0);

  const wordsByLines = $derived.by(() => {
    // Split by newlines to preserve explicit line breaks
    const lines = textValue.split('\n');

    return lines.flatMap((line) => {
      // Split each line into words
      const words = line.split(/(?:(?!\u00A0+)\s+)/);

      if (width == null) {
        // No width specified, only use explicit line breaks (if used)
        return [{ words }];
      } else {
        // Handle word wrapping within each line
        return words.reduce((result: { words: string[]; width?: number }[], item) => {
          const currentLine = result[result.length - 1];
          const itemWidth = getStringWidth(item, style) || 0;

          if (
            currentLine &&
            (width == null ||
              scaleToFit ||
              (currentLine.width || 0) + itemWidth + spaceWidth < width)
          ) {
            // Word can be added to an existing line
            currentLine.words.push(item);
            currentLine.width = currentLine.width || 0;
            currentLine.width += itemWidth + spaceWidth;
          } else {
            // Add first word to line or word is too long to scaleToFit on existing line
            const newLine = { words: [item], width: itemWidth };
            result.push(newLine);
          }

          return result;
        }, []);
      }
    });
  });

  const lineCount = $derived(wordsByLines.length);

  /**
   * Convert css value to pixel value (ex. 0.71em => 11.36)
   */
  function getPixelValue(cssValue: number | string) {
    // TODO: Properly measure pixel values using DOM (handle inherited font size, zoom, etc)

    if (typeof cssValue === 'number') return cssValue;

    const result = cssValue.match(/([\d.]+)(\D+)/);
    const number = Number(result?.[1]);
    switch (result?.[2]) {
      case 'px':
        return number;
      case 'em':
      case 'rem':
        return number * 16;
      default:
        return 0;
    }
  }

  const startDy = $derived.by(() => {
    if (verticalAnchor === 'start') {
      return getPixelValue(capHeight);
    } else if (verticalAnchor === 'middle') {
      return ((lineCount - 1) / 2) * -getPixelValue(lineHeight) + getPixelValue(capHeight) / 2;
    } else {
      return (lineCount - 1) * -getPixelValue(lineHeight);
    }
  });

  const scaleTransform = $derived.by(() => {
    if (
      scaleToFit &&
      lineCount > 0 &&
      typeof x == 'number' &&
      typeof y == 'number' &&
      typeof width == 'number'
    ) {
      const lineWidth = wordsByLines[0].width || 1;
      const sx = width / lineWidth;
      const sy = sx;
      const originX = x - sx * x;
      const originY = y - sy * y;
      return `matrix(${sx}, 0, 0, ${sy}, ${originX}, ${originY})`;
    } else {
      return '';
    }
  });

  const rotateTransform = $derived(rotate ? `rotate(${rotate}, ${x}, ${y})` : '');
  const transform = $derived(transformProp ?? `${scaleTransform} ${rotateTransform}`);

  function isValidXOrY(xOrY: string | number | undefined) {
    return (
      // number that is not NaN or Infinity
      (typeof xOrY === 'number' && Number.isFinite(xOrY)) ||
      // for percentage
      typeof xOrY === 'string'
    );
  }

  const motionX = createMotion(initialX, () => x, motion);
  const motionY = createMotion(initialY, () => y, motion);

  function render(
    ctx: CanvasRenderingContext2D,
    styleOverrides: ComputedStylesOptions | undefined
  ) {
    const effectiveLineHeight = getPixelValue(lineHeight);
    const baseY = getPixelValue(motionY.current) + getPixelValue(dy) + getPixelValue(startDy);
    const baseX = getPixelValue(motionX.current) + getPixelValue(dx);

    ctx.save();

    if (rotate !== undefined) {
      const centerX = getPixelValue(x);
      const centerY = getPixelValue(y);
      const radians = degreesToRadians(rotate);

      ctx.translate(centerX, centerY);
      ctx.rotate(radians);
      ctx.translate(-centerX, -centerY);
    }

    const styles = styleOverrides
      ? merge({ styles: { strokeWidth } }, styleOverrides)
      : {
          styles: {
            fill,
            fillOpacity,
            stroke,
            strokeWidth,
            opacity,
            paintOrder: 'stroke',
            textAnchor,
          },
          classes: cls(fill === undefined && 'fill-surface-content', className),
        };

    const computedStyles = getComputedStyles(ctx.canvas, styles);

    ctx.font = `${computedStyles.fontSize} ${computedStyles.fontFamily}`;

    const textAlign = textAnchor === 'middle' ? 'center' : textAnchor === 'end' ? 'end' : 'start';
    ctx.textAlign = textAlign;

    for (let index = 0; index < wordsByLines.length; index++) {
      const line = wordsByLines[index];
      const text = line.words.join(' ');

      // no need to manually adjust x for textAnchor since ctx.textAlign handles it
      const xPos = baseX;
      const yPos = baseY + index * effectiveLineHeight;

      renderText(
        ctx,
        text,
        {
          x: xPos,
          y: yPos,
        },
        styles
      );
    }

    ctx.restore();
  }

  // TODO: Use objectId to work around Svelte 4 reactivity issue (even when memoizing gradients)
  const fillKey = createKey(() => fill);
  const strokeKey = createKey(() => stroke);

  if (renderCtx === 'canvas') {
    registerCanvasComponent({
      name: 'Text',
      render,
      deps: () => [
        value,
        motionX.current,
        motionY.current,
        fillKey.current,
        strokeKey.current,
        strokeWidth,
        opacity,
        className,
        truncateConfig,
        rotate,
        lineHeight,
        textAnchor,
        verticalAnchor,
      ],
    });
  }
</script>

{#if renderCtx === 'svg'}
  <!-- `overflow: visible` allow contents to be shown outside element -->
  <!-- `paint-order: stroke` supports stroke outlining text  -->
  <svg
    x={dx}
    y={dy}
    {...svgProps}
    class={cls(layerClass('text-svg'), 'overflow-visible [paint-order:stroke]', svgProps?.class)}
    bind:this={svgRef}
  >
    {#if path}
      <defs>
        {#key path}
          <path bind:this={pathRef} id={pathId} d={path} />
        {/key}
      </defs>
      <text
        bind:this={ref}
        {dy}
        {...restProps}
        {fill}
        fill-opacity={fillOpacity}
        {stroke}
        stroke-width={strokeWidth}
        {opacity}
        transform={transformProp}
        class={cls(layerClass('text'), fill === undefined && 'fill-surface-content', className)}
      >
        <textPath
          style="text-anchor: {textAnchor};"
          dominant-baseline={dominantBaseline}
          href="#{pathId}"
          {startOffset}
          class={cls(layerClass('text-path'))}
        >
          {wordsByLines.map((line) => line.words.join(' ')).join()}
        </textPath>
      </text>
    {:else if isValidXOrY(x) && isValidXOrY(y)}
      <text
        bind:this={ref}
        x={motionX.current}
        y={motionY.current}
        {transform}
        text-anchor={textAnchor}
        dominant-baseline={dominantBaseline}
        {...restProps}
        {fill}
        fill-opacity={fillOpacity}
        {stroke}
        stroke-width={strokeWidth}
        {opacity}
        class={cls(layerClass('text'), fill === undefined && 'fill-surface-content', className)}
      >
        {#each wordsByLines as line, index}
          <tspan
            x={motionX.current}
            dy={index === 0 ? startDy : lineHeight}
            class={layerClass('text-tspan')}
          >
            {line.words.join(' ')}
          </tspan>
        {/each}
      </text>
    {/if}
  </svg>
{/if}
